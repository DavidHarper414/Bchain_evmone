#include "bls12.hpp"

namespace evmmax::bls12
{
bool validate(const Point& pt) noexcept
{
    if (pt.is_inf())
        return true;

    const evmmax::ModArith s{BLS12Mod};
    const auto xm = s.to_mont(pt.x);
    const auto ym = s.to_mont(pt.y);
    const auto y2 = s.mul(ym, ym);
    const auto x2 = s.mul(xm, xm);
    const auto x3 = s.mul(x2, xm);
    const auto _4 = s.to_mont(4);
    const auto x3_4 = s.add(x3, _4);
    return y2 == x3_4;
}

Point bls12_add(const Point& pt1, const Point& pt2) noexcept
{
    if (pt1.is_inf())
        return pt2;
    if (pt2.is_inf())
        return pt1;

    const evmmax::ModArith s{BLS12Mod};

    const auto p = ecc::to_proj(s, pt1);
    const auto q = ecc::to_proj(s, pt2);

    // b3 == 12 for y^2 == x^3 + 4
    const auto b3 = s.to_mont(12);
    const auto r = ecc::add(s, p, q, b3);

    return ecc::to_affine(s, field_inv, r);
}

bool bls12_add_precompile(const uint8_t* input, size_t input_size, uint8_t* output) noexcept
{
    using namespace intx;
    uint8_t input_padded[192]{};
    std::copy_n(input, std::min(input_size, sizeof(input_padded)), input_padded);

    const Point a{
        be::unsafe::load<uint384>(&input_padded[0]), be::unsafe::load<uint384>(&input_padded[48])};
    const Point b{be::unsafe::load<uint384>(&input_padded[96]),
        be::unsafe::load<uint384>(&input_padded[144])};

    if (!validate(a) || !validate(b))
        return false;

    const auto s = bls12_add(a, b);
    be::unsafe::store(output, s.x);
    be::unsafe::store(output + 48, s.y);
    return true;
}

uint384 field_inv(const evmmax::ModArith<uint384>& m, const uint384& x) noexcept
{
    // Computes modular exponentiation
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaa9
    // Operations: 376 squares 74 multiplies
    // Generated by github.com/mmcloughlin/addchain v0.4.0.
    //
    // Exponentiation computation is derived from the addition chain:
    //
    // _10       = 2*1
    // _100      = 2*_10
    // _1000     = 2*_100
    // _1001     = 1 + _1000
    // _1011     = _10 + _1001
    // _1101     = _10 + _1011
    // _10001    = _100 + _1101
    // _10100    = _1001 + _1011
    // _11001    = _1000 + _10001
    // _11010    = 1 + _11001
    // _110100   = 2*_11010
    // _110110   = _10 + _110100
    // _110111   = 1 + _110110
    // _1001101  = _11001 + _110100
    // _1001111  = _10 + _1001101
    // _1010101  = _1000 + _1001101
    // _1011101  = _1000 + _1010101
    // _1100111  = _11010 + _1001101
    // _1101001  = _10 + _1100111
    // _1110111  = _11010 + _1011101
    // _1111011  = _100 + _1110111
    // _10001001 = _110100 + _1010101
    // _10010101 = _11010 + _1111011
    // _10010111 = _10 + _10010101
    // _10101001 = _10100 + _10010101
    // _10110001 = _1000 + _10101001
    // _10111111 = _110110 + _10001001
    // _11000011 = _100 + _10111111
    // _11010000 = _1101 + _11000011
    // _11010111 = _10100 + _11000011
    // _11100001 = _10001 + _11010000
    // _11100101 = _100 + _11100001
    // _11101011 = _10100 + _11010111
    // _11110101 = _10100 + _11100001
    // _11111111 = _10100 + _11101011
    // i57       = ((_10111111 + _11100001) << 8 + _10001) << 11 + _11110101
    // i85       = ((i57 << 11 + _11100101) << 8 + _11111111) << 7
    // i107      = ((_1001101 + i85) << 9 + _1101001) << 10 + _10110001
    // i131      = ((i107 << 7 + _1011101) << 9 + _1111011) << 6
    // i154      = ((_11001 + i131) << 11 + _1101001) << 9 + _11101011
    // i182      = ((i154 << 10 + _11010111) << 6 + _11001) << 10
    // i205      = ((_1110111 + i182) << 9 + _10010111) << 11 + _1001111
    // i235      = ((i205 << 10 + _11100001) << 9 + _10001001) << 9
    // i256      = ((_10111111 + i235) << 8 + _1100111) << 10 + _11000011
    // i284      = ((i256 << 9 + _10010101) << 12 + _1111011) << 5
    // i305      = ((_1011 + i284) << 11 + _1111011) << 7 + _1001
    // i337      = ((i305 << 13 + _11110101) << 9 + _10111111) << 8
    // i359      = ((_11111111 + i337) << 8 + _11101011) << 11 + _10101001
    // i383      = ((i359 << 8 + _11111111) << 8 + _11111111) << 6
    // i405      = ((_110111 + i383) << 10 + _11111111) << 9 + _11111111
    // i431      = ((i405 << 8 + _11111111) << 8 + _11111111) << 8
    // return      ((_11111111 + i431) << 7 + _1010101) << 9 + _10101001

    // Allocate Temporaries.
    uint384 z;
    uint384 t0;
    uint384 t1;
    uint384 t2;
    uint384 t3;
    uint384 t4;
    uint384 t5;
    uint384 t6;
    uint384 t7;
    uint384 t8;
    uint384 t9;
    uint384 t10;
    uint384 t11;
    uint384 t12;
    uint384 t13;
    uint384 t14;
    uint384 t15;
    uint384 t16;
    uint384 t17;
    uint384 t18;
    uint384 t19;
    uint384 t20;
    uint384 t21;
    uint384 t22;
    uint384 t23;
    uint384 t24;
    uint384 t25;


    // Step 1: z = x^0x2
    z = m.mul(x, x);

    // Step 2: t3 = x^0x4
    t3 = m.mul(z, z);

    // Step 3: t10 = x^0x8
    t10 = m.mul(t3, t3);

    // Step 4: t6 = x^0x9
    t6 = m.mul(x, t10);

    // Step 5: t8 = x^0xb
    t8 = m.mul(z, t6);

    // Step 6: t5 = x^0xd
    t5 = m.mul(z, t8);

    // Step 7: t24 = x^0x11
    t24 = m.mul(t3, t5);

    // Step 8: t1 = x^0x14
    t1 = m.mul(t6, t8);

    // Step 9: t17 = x^0x19
    t17 = m.mul(t10, t24);

    // Step 10: t9 = x^0x1a
    t9 = m.mul(x, t17);

    // Step 11: t12 = x^0x34
    t12 = m.mul(t9, t9);

    // Step 12: t4 = x^0x36
    t4 = m.mul(z, t12);

    // Step 13: t2 = x^0x37
    t2 = m.mul(x, t4);

    // Step 14: t22 = x^0x4d
    t22 = m.mul(t17, t12);

    // Step 15: t14 = x^0x4f
    t14 = m.mul(z, t22);

    // Step 16: t0 = x^0x55
    t0 = m.mul(t10, t22);

    // Step 17: t20 = x^0x5d
    t20 = m.mul(t10, t0);

    // Step 18: t11 = x^0x67
    t11 = m.mul(t9, t22);

    // Step 19: t19 = x^0x69
    t19 = m.mul(z, t11);

    // Step 20: t16 = x^0x77
    t16 = m.mul(t9, t20);

    // Step 21: t7 = x^0x7b
    t7 = m.mul(t3, t16);

    // Step 22: t12 = x^0x89
    t12 = m.mul(t12, t0);

    // Step 23: t9 = x^0x95
    t9 = m.mul(t9, t7);

    // Step 24: t15 = x^0x97
    t15 = m.mul(z, t9);

    // Step 25: z = x^0xa9
    z = m.mul(t1, t9);

    // Step 26: t21 = x^0xb1
    t21 = m.mul(t10, z);

    // Step 27: t4 = x^0xbf
    t4 = m.mul(t4, t12);

    // Step 28: t10 = x^0xc3
    t10 = m.mul(t3, t4);

    // Step 29: t5 = x^0xd0
    t5 = m.mul(t5, t10);

    // Step 30: t18 = x^0xd7
    t18 = m.mul(t1, t10);

    // Step 31: t13 = x^0xe1
    t13 = m.mul(t24, t5);

    // Step 32: t23 = x^0xe5
    t23 = m.mul(t3, t13);

    // Step 33: t3 = x^0xeb
    t3 = m.mul(t1, t18);

    // Step 34: t5 = x^0xf5
    t5 = m.mul(t1, t13);

    // Step 35: t1 = x^0xff
    t1 = m.mul(t1, t3);

    // Step 36: t25 = x^0x1a0
    t25 = m.mul(t4, t13);

    // Step 44: t25 = x^0x1a000
    for (int i = 0; i < 8; ++i)
        t25 = m.mul(t25, t25);

    // Step 45: t24 = x^0x1a011
    t24 = m.mul(t24, t25);

    // Step 56: t24 = x^0xd008800
    for (int i = 0; i < 11; ++i)
        t24 = m.mul(t24, t24);

    // Step 57: t24 = x^0xd0088f5
    t24 = m.mul(t5, t24);

    // Step 68: t24 = x^0x680447a800
    for (int i = 0; i < 11; ++i)
        t24 = m.mul(t24, t24);

    // Step 69: t23 = x^0x680447a8e5
    t23 = m.mul(t23, t24);

    // Step 77: t23 = x^0x680447a8e500
    for (int i = 0; i < 8; ++i)
        t23 = m.mul(t23, t23);

    // Step 78: t23 = x^0x680447a8e5ff
    t23 = m.mul(t1, t23);

    // Step 85: t23 = x^0x340223d472ff80
    for (int i = 0; i < 7; ++i)
        t23 = m.mul(t23, t23);

    // Step 86: t22 = x^0x340223d472ffcd
    t22 = m.mul(t22, t23);

    // Step 95: t22 = x^0x680447a8e5ff9a00
    for (int i = 0; i < 9; ++i)
        t22 = m.mul(t22, t22);

    // Step 96: t22 = x^0x680447a8e5ff9a69
    t22 = m.mul(t19, t22);

    // Step 106: t22 = x^0x1a0111ea397fe69a400
    for (int i = 0; i < 10; ++i)
        t22 = m.mul(t22, t22);

    // Step 107: t21 = x^0x1a0111ea397fe69a4b1
    t21 = m.mul(t21, t22);

    // Step 114: t21 = x^0xd0088f51cbff34d25880
    for (int i = 0; i < 7; ++i)
        t21 = m.mul(t21, t21);

    // Step 115: t20 = x^0xd0088f51cbff34d258dd
    t20 = m.mul(t20, t21);

    // Step 124: t20 = x^0x1a0111ea397fe69a4b1ba00
    for (int i = 0; i < 9; ++i)
        t20 = m.mul(t20, t20);

    // Step 125: t20 = x^0x1a0111ea397fe69a4b1ba7b
    t20 = m.mul(t7, t20);

    // Step 131: t20 = x^0x680447a8e5ff9a692c6e9ec0
    for (int i = 0; i < 6; ++i)
        t20 = m.mul(t20, t20);

    // Step 132: t20 = x^0x680447a8e5ff9a692c6e9ed9
    t20 = m.mul(t17, t20);

    // Step 143: t20 = x^0x340223d472ffcd3496374f6c800
    for (int i = 0; i < 11; ++i)
        t20 = m.mul(t20, t20);

    // Step 144: t19 = x^0x340223d472ffcd3496374f6c869
    t19 = m.mul(t19, t20);

    // Step 153: t19 = x^0x680447a8e5ff9a692c6e9ed90d200
    for (int i = 0; i < 9; ++i)
        t19 = m.mul(t19, t19);

    // Step 154: t19 = x^0x680447a8e5ff9a692c6e9ed90d2eb
    t19 = m.mul(t3, t19);

    // Step 164: t19 = x^0x1a0111ea397fe69a4b1ba7b6434bac00
    for (int i = 0; i < 10; ++i)
        t19 = m.mul(t19, t19);

    // Step 165: t18 = x^0x1a0111ea397fe69a4b1ba7b6434bacd7
    t18 = m.mul(t18, t19);

    // Step 171: t18 = x^0x680447a8e5ff9a692c6e9ed90d2eb35c0
    for (int i = 0; i < 6; ++i)
        t18 = m.mul(t18, t18);

    // Step 172: t17 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d9
    t17 = m.mul(t17, t18);

    // Step 182: t17 = x^0x1a0111ea397fe69a4b1ba7b6434bacd76400
    for (int i = 0; i < 10; ++i)
        t17 = m.mul(t17, t17);

    // Step 183: t16 = x^0x1a0111ea397fe69a4b1ba7b6434bacd76477
    t16 = m.mul(t16, t17);

    // Step 192: t16 = x^0x340223d472ffcd3496374f6c869759aec8ee00
    for (int i = 0; i < 9; ++i)
        t16 = m.mul(t16, t16);

    // Step 193: t15 = x^0x340223d472ffcd3496374f6c869759aec8ee97
    t15 = m.mul(t15, t16);

    // Step 204: t15 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b800
    for (int i = 0; i < 11; ++i)
        t15 = m.mul(t15, t15);

    // Step 205: t14 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f
    t14 = m.mul(t14, t15);

    // Step 215: t14 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13c00
    for (int i = 0; i < 10; ++i)
        t14 = m.mul(t14, t14);

    // Step 216: t13 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13ce1
    t13 = m.mul(t13, t14);

    // Step 225: t13 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c200
    for (int i = 0; i < 9; ++i)
        t13 = m.mul(t13, t13);

    // Step 226: t12 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c289
    t12 = m.mul(t12, t13);

    // Step 235: t12 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f3851200
    for (int i = 0; i < 9; ++i)
        t12 = m.mul(t12, t12);

    // Step 236: t12 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf
    t12 = m.mul(t4, t12);

    // Step 244: t12 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf00
    for (int i = 0; i < 8; ++i)
        t12 = m.mul(t12, t12);

    // Step 245: t11 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf67
    t11 = m.mul(t11, t12);

    // Step 255: t11 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13ce144afd9c00
    for (int i = 0; i < 10; ++i)
        t11 = m.mul(t11, t11);

    // Step 256: t10 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13ce144afd9cc3
    t10 = m.mul(t10, t11);

    // Step 265: t10 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb398600
    for (int i = 0; i < 9; ++i)
        t10 = m.mul(t10, t10);

    // Step 266: t9 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb398695
    t9 = m.mul(t9, t10);

    // Step 278: t9 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb398695000
    for (int i = 0; i < 12; ++i)
        t9 = m.mul(t9, t9);

    // Step 279: t9 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b
    t9 = m.mul(t7, t9);

    // Step 284: t9 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f60
    for (int i = 0; i < 5; ++i)
        t9 = m.mul(t9, t9);

    // Step 285: t8 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b
    t8 = m.mul(t8, t9);

    // Step 296: t8 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b5800
    for (int i = 0; i < 11; ++i)
        t8 = m.mul(t8, t8);

    // Step 297: t7 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b
    t7 = m.mul(t7, t8);

    // Step 304: t7 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13ce144afd9cc34a83dac3d80
    for (int i = 0; i < 7; ++i)
        t7 = m.mul(t7, t7);

    // Step 305: t6 = x^0x680447a8e5ff9a692c6e9ed90d2eb35d91dd2e13ce144afd9cc34a83dac3d89
    t6 = m.mul(t6, t7);

    // Step 318: t6 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b12000
    for (int i = 0; i < 13; ++i)
        t6 = m.mul(t6, t6);

    // Step 319: t5 = x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f5
    t5 = m.mul(t5, t6);

    // Step 328: t5 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241ea00
    for (int i = 0; i < 9; ++i)
        t5 = m.mul(t5, t5);

    // Step 329: t4 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabf
    t4 = m.mul(t4, t5);

    // Step 337: t4 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabf00
    for (int i = 0; i < 8; ++i)
        t4 = m.mul(t4, t4);

    // Step 338: t4 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfff
    t4 = m.mul(t1, t4);

    // Step 346: t4 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfff00
    for (int i = 0; i < 8; ++i)
        t4 = m.mul(t4, t4);

    // Step 347: t3 = x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb
    t3 = m.mul(t3, t4);

    // Step 358: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff5800
    for (int i = 0; i < 11; ++i)
        t3 = m.mul(t3, t3);

    // Step 359: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9
    t3 = m.mul(z, t3);

    // Step 367: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a900
    for (int i = 0; i < 8; ++i)
        t3 = m.mul(t3, t3);

    // Step 368: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ff
    t3 = m.mul(t1, t3);

    // Step 376: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ff00
    for (int i = 0; i < 8; ++i)
        t3 = m.mul(t3, t3);

    // Step 377: t3 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ffff
    t3 = m.mul(t1, t3);

    // Step 383: t3 =
    // x^0x340223d472ffcd3496374f6c869759aec8ee9709e70a257ece61a541ed61ec483d57fffd62a7fffc0
    for (int i = 0; i < 6; ++i)
        t3 = m.mul(t3, t3);

    // Step 384: t2 =
    // x^0x340223d472ffcd3496374f6c869759aec8ee9709e70a257ece61a541ed61ec483d57fffd62a7ffff7
    t2 = m.mul(t2, t3);

    // Step 394: t2 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ffffdc00
    for (int i = 0; i < 10; ++i)
        t2 = m.mul(t2, t2);

    // Step 395: t2 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ffffdcff
    t2 = m.mul(t1, t2);

    // Step 404: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9fe00
    for (int i = 0; i < 9; ++i)
        t2 = m.mul(t2, t2);

    // Step 405: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feff
    t2 = m.mul(t1, t2);

    // Step 413: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feff00
    for (int i = 0; i < 8; ++i)
        t2 = m.mul(t2, t2);

    // Step 414: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffff
    t2 = m.mul(t1, t2);

    // Step 422: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffff00
    for (int i = 0; i < 8; ++i)
        t2 = m.mul(t2, t2);

    // Step 423: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffff
    t2 = m.mul(t1, t2);

    // Step 431: t2 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffff00
    for (int i = 0; i < 8; ++i)
        t2 = m.mul(t2, t2);

    // Step 432: t1 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffff
    t1 = m.mul(t1, t2);

    // Step 439: t1 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ffffdcff7fffffff80
    for (int i = 0; i < 7; ++i)
        t1 = m.mul(t1, t1);

    // Step 440: t0 =
    // x^0xd0088f51cbff34d258dd3db21a5d66bb23ba5c279c2895fb39869507b587b120f55ffff58a9ffffdcff7fffffffd5
    t0 = m.mul(t0, t1);

    // Step 449: t0 =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa00
    for (int i = 0; i < 9; ++i)
        t0 = m.mul(t0, t0);

    // Step 450: z =
    // x^0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaa9
    z = m.mul(z, t0);

    return z;
}

}  // namespace evmmax::bls12
